[%
var gs: DagSet := DagSet.allInstances().at(0);
var mutexTask: String;
var NUM_THREADS: Integer;
var i: Integer;
var mutex: String;
var lastNode: Integer;
mutex=""; 

for (dag in gs.dagCollection.at(index)){ 
	for (edge in dag.edge){ 
		mutex=mutex+edge.name;
	if (hasMore)
		mutex=mutex+",";
	}

%]
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include "_hgr.h"
#include "hgr_dependencies.h"

hgr_dependency_t [%=mutex%],lock_start;
PREM_node_t *[%=dag.name%]_data[[%=dag.node.size()%]];
volatile long int var_condition1=0;
long double wcet_per_task[[%=dag.node.size()%]];
double FREQUENCY;

void [%=dag.name%]_pre_load_tasks(){
	int granularity=[%=dag.step%];
	[%i=0;for (task in dag.node){%] 	
	
	wcet_per_task[[%=i%]]=[%=task.miet%];
	[%if(dag.mem_type.name="prem"){%]
	[%=dag.name%]_data[[%=i%]]=hgr_load_PREM_node([%=task.mem_access%],"[%=task.mem_unit%]",[%=dag.mem_type.value%],granularity,wcet_per_task[[%=i%]],FREQUENCY,[%=i%]);
	[%}else {%]
	[%=dag.name%]_data[[%=i%]]=hgr_load_SPARSE_node([%=task.mem_access%],"[%=task.mem_unit%]",[%=dag.mem_type.value%],granularity,[%=dag.stride%],wcet_per_task[[%=i%]],FREQUENCY,[%=i%]);
	[%}%]
	[%i++;}%]
	
}

void [%=dag.name%]_create_dependency(){	
	[%for (edge in dag.edge){%]
	hgr_init_dependency(&[%=edge.name%],NULL);
	hgr_wait_dependency(&[%=edge.name%]);	
	[%}%]
	hgr_init_dependency(&lock_start1,NULL);
	hgr_wait_dependency(&lock_start1);
}

void [%=dag.name%]_destroy_dependency(){
	[%for (edge in dag.edge){%]
	hgr_destroy_dependency(&[%=edge.name%]);
	[%}%]
	hgr_destroy_dependency(&lock_start1);
}

void *[%=dag.name%]_wait_finish() {
	while(var_condition1!=[%=dag.node.size()%])
		; 
	return 0;
}

void [%=dag.name%]_start() {
	hgr_release_dependency(&lock_start);
}

void [%=dag.name%]_finish() {
	hgr_thread_create(0, 100, NULL, &[%=dag.name%]_wait_finish, (void *)0);  
}

[%i=0;for (task in dag.node){%]
void *[%=task.name%](){
[%if(dag.mem_type.name="prem"){%]
[%=prem_memory(dag,task,i)%]
[%}else {%]
[%=sparse_memory(dag,task,i)%]
[%}%]

}
[%i++;}%]

void [%=dag.name%](){
	FREQUENCY=(double)(mhz()/1000.0);

	printf("FREQ: %f \n",FREQUENCY);
	G1_pre_load_tasks();
	hgr_prepare_task(0,3);

	while(1){
		var_condition1=0;
		G1_create_dependency();
	
		pthread_t threads[[%=dag.node.size%]];
		[%=dag.name%]_mutexCreate();
		[%i=0;
		for (node in dag.node){%]
		
		hgr_thread_create(0,[%=i%], NULL, &[%=node.name%], (void *)[%=i%]);[%i++;}%]  
 		clock_gettime(CLOCK_MONOTONIC, &tstart);	

		G1_start();
		G1_finish();~
		
 		clock_gettime(CLOCK_MONOTONIC, &tend);
 		timeTaken=(( ((double)tend.tv_sec + 1.0e-9*tend.tv_nsec) - ((double)tstart.tv_sec + 1.0e-9*tstart.tv_nsec)))*1000;
 		printf("Total execution time: %f miliseconds\n",timeTaken);
		
		hgr_release_dependency(&lock_start);
		
		hgr_wait_dependency(&lock_end);
		[%i=0;
		for (node in dag.node){%]  
		hgr_thread_join(0,[%=i%]);[%i++;}
		%]
		
		hgr_free_task(0);
		[%=dag.name%]_destroy_dependency();
		hgr_wait_for_period(0);
	}
}

[%}%]

[%
@template
operation prem_memory(dag:Dag,task:Node,i:Integer){%]
	[%var mutexTask:String;%]
	//printf("Hi im the node [%=task.name%]\n");  //[%=task.comment%]
	
	pthread_mutex_trylock(&lock_start);
 	volatile char *ptr_dst = (char *)malloc(G1_data[0]->data_size);
	
	hgr_prem_memphase([%=dag.name%]_data[[%=i%]]); //Mem phase
	
	[%for (edge in dag.edge){
		if(edge.trg.name=task.name){
			mutexTask=edge.name;%]
	hgr_wait_dependency(&[%=mutexTask%]);
		[%}%]
	[%}%]
	hgr_PREM_compute_node([%=dag.name%]_data[[%=i%]],ptr_dst); //Mem+Computation phase
	[%for (edge in dag.edge){
		if(edge.src.name=task.name){
			mutexTask=edge.name;%]
	hgr_release_dependency(&[%=mutexTask%]);
		[%}%]
	[%}%]
	
	var_condition1++;
 	free(ptr_dst);
	hgr_exit();

	return 0;
[%}

@template
operation sparse_memory(dag:Dag,task:Node,i:Integer){%]
	[%var mutexTask:String;%]
	//printf("Hi im the node [%=task.name%]\n");  //[%=task.comment%]

	pthread_mutex_trylock(&lock_start);
	[%for (edge in dag.edge){
		if(edge.trg.name=task.name){
			mutexTask=edge.name;%]
	hgr_wait_dependency(&[%=mutexTask%]); 
		[%}%]
	[%}%]
	
	hgr_SPARSE_compute_node([%=dag.name%]_data[[%=i%]],pointer[[%=i%]]); //Mem & Computation phase
	
	[%for (edge in dag.edge){
		if(edge.src.name=task.name){
			mutexTask=edge.name;%]
	hgr_release_dependency(&[%=mutexTask%]);
		[%}%]
	[%}%]

	var_condition1++;
	hgr_exit();
	return 0;
[%}%]




